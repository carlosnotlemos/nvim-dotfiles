"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAliasedImport = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const json5_1 = __importDefault(require("json5"));
const lilconfig_1 = require("lilconfig");
const resolveJson5File_1 = require("./resolveJson5File");
const validate = {
    string: (x) => typeof x === 'string',
    tsconfigPaths: (x) => {
        if (typeof x !== 'object' || x == null || Array.isArray(x)) {
            return false;
        }
        const paths = x;
        const isValid = Object.values(paths).every(value => {
            return (Array.isArray(value) &&
                value.length > 0 &&
                value.every(validate.string));
        });
        return isValid;
    },
};
/**
 * Attempts to resolve aliased file paths using tsconfig or jsconfig
 *
 * returns null if paths could not be resolved, absolute filepath otherwise
 * @see https://www.typescriptlang.org/tsconfig#paths
 */
const resolveAliasedImport = ({ location, importFilepath, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const searcher = (0, lilconfig_1.lilconfigSync)('', {
        searchPlaces: ['tsconfig.json', 'jsconfig.json'],
        loaders: {
            '.json': (_, content) => json5_1.default.parse(content),
        },
    });
    let config = searcher.search(location);
    if (config == null) {
        return null;
    }
    let configLocation = path_1.default.dirname(config.filepath);
    let paths = (_b = (_a = config.config) === null || _a === void 0 ? void 0 : _a.compilerOptions) === null || _b === void 0 ? void 0 : _b.paths;
    let pathsBase = configLocation;
    let potentialBaseUrl = (_d = (_c = config.config) === null || _c === void 0 ? void 0 : _c.compilerOptions) === null || _d === void 0 ? void 0 : _d.baseUrl;
    let baseUrl = validate.string(potentialBaseUrl)
        ? path_1.default.resolve(configLocation, potentialBaseUrl)
        : null;
    let depth = 0;
    while ((!paths || !baseUrl) && ((_e = config.config) === null || _e === void 0 ? void 0 : _e.extends) && depth++ < 10) {
        config = (0, resolveJson5File_1.resolveJson5File)({
            path: config.config.extends,
            base: configLocation,
        });
        if (config == null) {
            return null;
        }
        configLocation = path_1.default.dirname(config.filepath);
        if (!paths && ((_g = (_f = config.config) === null || _f === void 0 ? void 0 : _f.compilerOptions) === null || _g === void 0 ? void 0 : _g.paths)) {
            paths = config.config.compilerOptions.paths;
            pathsBase = configLocation;
        }
        if (!baseUrl && ((_j = (_h = config.config) === null || _h === void 0 ? void 0 : _h.compilerOptions) === null || _j === void 0 ? void 0 : _j.baseUrl)) {
            potentialBaseUrl = config.config.compilerOptions.baseUrl;
            baseUrl = validate.string(potentialBaseUrl)
                ? path_1.default.resolve(configLocation, potentialBaseUrl)
                : null;
        }
    }
    if (validate.tsconfigPaths(paths)) {
        baseUrl = baseUrl || pathsBase;
        for (const alias in paths) {
            const aliasRe = new RegExp(alias.replace('*', '(.+)'), '');
            const aliasMatch = importFilepath.match(aliasRe);
            if (aliasMatch == null)
                continue;
            for (const potentialAliasLocation of paths[alias]) {
                const resolvedFileLocation = path_1.default.resolve(baseUrl, potentialAliasLocation
                    // "./utils/*" -> "./utils/style.module.css"
                    .replace('*', aliasMatch[1]));
                if (!fs_1.default.existsSync(resolvedFileLocation))
                    continue;
                return resolvedFileLocation;
            }
        }
    }
    // if paths is defined, but no paths match
    // then baseUrl will not fallback to "."
    // if not using paths to find an alias, baseUrl must be defined
    // so here we only try and resolve the file if baseUrl is explcitly set and valid
    // i.e. if no baseUrl is provided
    // then no imports relative to baseUrl on its own are allowed, only relative to paths
    if (baseUrl) {
        const resolvedFileLocation = path_1.default.resolve(baseUrl, importFilepath);
        if (fs_1.default.existsSync(resolvedFileLocation)) {
            return resolvedFileLocation;
        }
    }
    return null;
};
exports.resolveAliasedImport = resolveAliasedImport;
